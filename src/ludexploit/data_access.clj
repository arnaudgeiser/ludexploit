(ns ludexploit.data-access
  (:require [clojure.java.jdbc :as j]
            [clojure.set :refer :all]
            [cheshire.core :refer [generate-string parse-string]]
            [php_clj.core :refer [php->clj clj->php]]
            [ludexploit.domain :as d]
            [clj-time.core :as t]
            [clj-time.coerce :as c]
            [clj-time.format :as f]
            [ludexploit.config :refer [config]])
  (:import com.mchange.v2.c3p0.ComboPooledDataSource org.joda.time.DateTimeZone))

(def db-spec
  "Initialize the DB specification from the configuration file."
  (:db @config))

(defn pool
    "Create datasource from a C3PO connection pool"
    [{:keys [classname subprotocol subname user password]}]
    (let [cpds (doto (ComboPooledDataSource.)
                 (.setDriverClass classname)
                 (.setJdbcUrl (str "jdbc:" subprotocol ":" subname))
                 (.setUser user)
                 (.setPassword password)
                 (.setMaxIdleTimeExcessConnections (* 30 60))
                 (.setMaxIdleTime (* 3 60 60)))]
      {:datasource cpds}))

(def pooled-db
  "Lazy initialize connection pooled only once"
  (delay (pool db-spec)))

(defn db-connection
  "Get one connection from the connection pool"
  []
  @pooled-db)

(defn has-booking-meta?
  "Determine if an event contains an element :booking_meta.
	This element can be absent if there is no inscription on it"
  [event]
  (not (empty? (:booking_meta event))))

(defn convert-booking-meta
  "Convert the :booking_meta element which is a PHP serialized object
	into a clojure data strcture. If the element is not present, then return
	an empty object"
  [event]
  (if (has-booking-meta? event)
     (php->clj (:booking_meta event)) {}))

(defn to-date-time
 "Convert a java.sql.Date in one org.jodatime.DateTime according to one date and one hour"
 [sql-date sql-hour]
 (let [to-date #(.withZone (c/from-sql-date %) (DateTimeZone/forID "Europe/Zurich"))
       date (to-date sql-date)
       hour (to-date sql-hour)]
   (-> date
     (.plusHours (.getHourOfDay hour))
     (.plusMinutes (.getMinuteOfHour hour))
     (.withZone (DateTimeZone/forID "Europe/Zurich")))))

(defn raw-att-to-att
  "I absolutely don't know what I'm doing...
	Attendees are stored in a so complex data structure
	The aim of this function is to extract the attendee's name from the stucture as a seq"
  [rawatt]
  (for [a rawatt
         b (val a)
         [k v] b
         :when (= "attendee_name" k)]
       v))

(defn booking-meta-to-data
  "Convert the booking_meta object as readable values"
  [booking-meta]
  (let [registration (get booking-meta "registration")
        username (get registration "user_name")
        email (get registration "user_email")
        attendees (get booking-meta "attendees")]
    {:username username :user_email email :attendees (raw-att-to-att attendees)}))

(defn convert-booking-meta-from-event
  "Extract booking_meta from event"
  [event]
  (->> event
    (convert-booking-meta)
    (booking-meta-to-data)
    (merge event)))

(defn convert-booking-meta-from-events
  "Extract booking_meta from a seq of events"
  [events]
  (map convert-booking-meta-from-event events))

(defn readable-events
  "Convert a seq of events from the database to a readable-form"
  [events]
  (->> events
    (map #(assoc % :hasinscriptions (= (:meta_value %) "1")))
    (convert-booking-meta-from-events)))

(defn convert-event-dates [event]
  (let [start (to-date-time (:event_start_date event) (:start_time event))
         end (to-date-time (:event_end_date event) (:end_time event))]
   (merge event {:event_start_date start :event_end_date end})))

(def event-keys
  [:id
   :event_end_date
   :status
   :price
   :event_start_date
   :event_name
   :start_time
   :end_time
   :ticket_spaces
   :meta_value
   :description
   :hasinscriptions])

(defn grouped
  [events]
  (for [[base-event grouped-events] (group-by #(select-keys % event-keys) events)
        :let [{:keys [ticket_spaces price event_start_date start_time price event_end_date end_time]} base-event
               categories (set (map #(:category %) grouped-events))
               reservations (set (map (fn [r] {:attendees (:attendees r) :user_email (:user_email r) :username (:username r) :id (:booking_id r)}) grouped-events))
               participants (d/count-participants reservations)
               event (assoc base-event
                        :categories categories
                        :participants participants
                        :is_full (> participants ticket_spaces)
                      :free (or (nil? price) (== 0 price))
                        :event_start_date (to-date-time event_start_date start_time)
                        :event_end_date (to-date-time event_end_date end_time))]]
       (if
              (= participants 0)
              (assoc event :reservations [])
              (assoc event :reservations reservations))))

(defn search-events [o]
  (let [{:keys [festival-id user-id event-id start-date]} o]
   (-> (j/query (db-connection) (concat [(str "select distinct wp_em_events.event_id as id,
																	wp_em_bookings.booking_id,
																	wp_em_events.post_content as description,
																	event_name,
																	event_start_date,
																	event_end_date,
																	event_start_time as start_time,
																	event_end_time as end_time,
																	event_status as status,
																	event_spaces,
																	ticket_price as price,
																	ticket_spaces,
																	meta_value,
																	booking_meta,
																	wp_terms.name as category
										from wp_em_events
										join wp_posts on wp_posts.id=wp_em_events.post_id
										join wp_em_tickets on wp_em_tickets.event_id=wp_em_events.event_id
										left join wp_em_bookings on wp_em_events.event_id=wp_em_bookings.event_id
											and (wp_em_bookings.booking_status=1 or wp_em_bookings.booking_status is null)
										left outer join wp_postmeta as insmeta on insmeta.post_id=wp_posts.id and insmeta.meta_key='inscription_mode'
										left outer join wp_users on wp_em_bookings.person_id=wp_users.id
										left outer join wp_term_relationships on wp_term_relationships.object_id=wp_posts.id
										left outer join wp_term_taxonomy on wp_term_taxonomy.term_taxonomy_id=wp_term_relationships.term_taxonomy_id
										left outer join wp_terms on wp_terms.term_id=wp_term_taxonomy.term_id
										join (select distinct wp_em_events.event_id from wp_em_events
													join wp_em_tickets on wp_em_events.event_id=wp_em_tickets.event_id
													left outer join wp_em_locations on wp_em_events.location_id=wp_em_locations.location_id
													join wp_postmeta on wp_postmeta.post_id=wp_em_events.post_id
													join wp_postmeta as meta2 on meta2.post_id=wp_em_events.post_id"
                                          (if festival-id (str " where wp_postmeta.meta_value=? and wp_postmeta.meta_key='festival_id'"))
                                          ") b
										on b.event_id=wp_em_events.event_id
										where 1=1"
                                          (if user-id " and wp_users.id=?")
                                          (if start-date " and event_start_date>=? and event_start_date<=?")
                                          (if event-id " and wp_em_events.event_id=?")
                                          " order by event_name")] (flatten (vals o))))
    (readable-events)
    (grouped))))


(defn search-events-by-festival [idFestival]
  (search-events (array-map :festival-id idFestival)))

(defn search-events-by-festival-user [idFestival idUser]
  (search-events (array-map :festival-id idFestival :user-id idUser)))

(defn search-events-by-date [date]
  (search-events (array-map :start-date date)))

(defn search-event [idEvent]
  (-> (search-events (array-map :event-id idEvent))
      (first)))

(defn search-user [username]
  (first (j/query (db-connection) ["select * from wp_users where user_login=?" username])))

(defn has-reservations [{:keys [user_id event_id]}]
  (->> (j/query (db-connection) ["select
														 count(*) as count
														 from wp_em_bookings b
														 join wp_em_events e on b.event_id=e.event_id
														 where person_id=? and e.event_id=? and (b.booking_status=1 or b.booking_status is null)" user_id event_id])
       (first)
       (:count)
       (zero?)
       (not)))

(defn search-reservations [idFestival idUser]
  (->> (j/query (db-connection) ["select
															b.booking_spaces as places,
															e.event_id,
															e.event_name,
															e.event_start_date,
															e.event_end_date,
															e.event_start_time as start_time,
															e.event_end_time as end_time
														 from wp_em_bookings b
														 join wp_em_events e on b.event_id=e.event_id
														 join wp_postmeta on wp_postmeta.post_id=e.post_id and wp_postmeta.meta_value=? and wp_postmeta.meta_key='festival_id'
														 where person_id=? and (b.booking_status=1 or b.booking_status is null)" idFestival idUser])
       (map #(convert-event-dates %))))

(defn search-awaiting-payments [idFestival]
  (->> (j/query (db-connection) ["select
															b.booking_spaces as places,
															b.booking_date as date,
															e.event_id,
															e.event_name,
															e.event_start_date,
															e.event_end_date,
															e.event_start_time as start_time,
															e.event_end_time as end_time
														 from wp_em_bookings b
														 join wp_em_events e on b.event_id=e.event_id
														 join wp_postmeta on wp_postmeta.post_id=e.post_id and wp_postmeta.meta_value=? and wp_postmeta.meta_key='festival_id'
														 where b.booking_status=4
														 order by e.event_id"
                                 idFestival])
     (group-by (fn [r] (select-keys r [:event_id :event_name :event_start_date :event_end_date])))))

(defn search-places []
  (j/query (db-connection) "select location_id as id, location_name as name, location_address as address, location_town as city, location_postcode as npa, location_latitude as latitude, location_longitude as longitude from wp_em_locations"))

(defn create-game [{name :name
                    nbplayers :nbplayers
                    duration :duration
                    start :start
                    device :device
                    location :location
                    subscriptions :subscriptions
                    players :weare}]
  (j/execute! (db-connection) ["insert into games (name,nb_players,duration,start,device,location,subscriptions)
																values (?,?,?,?,?,?,?)"
                                   name
                                   nbplayers
                                   duration
                                   (c/to-sql-time (f/parse (f/formatters :date-time-parser) start))
                                   device
                                   location
                                   (generate-string subscriptions)]))

(defn to-domain-players [game]
  (let [subscriptions (parse-string (:subscriptions game))
         players (reduce #(+ (Integer. %2) %1) 0 (vals subscriptions))]
       (merge game {:subscriptions subscriptions :players players})))

(defn search-games []
  (->>
     (j/query (db-connection) ["select id, device, name, nb_players, location, start, duration, subscriptions
															 from games where start>?
															 order by start asc" (c/to-sql-time (t/minus (t/now) (t/hours 1)))])
     (map #(to-domain-players %))))


(defn search-game [id]
  (->>
     (j/query (db-connection) ["select id, device, name, nb_players, location, start, duration, subscriptions from games where id=?" id])
     (map #(to-domain-players %))
     (first)))

(defn update-game [{id :id, subscriptions :subscriptions}]
    (j/execute! (db-connection) ["update games set subscriptions=? where id=?" (generate-string subscriptions) id]))

(defn delete-game [{id :id}]
  (j/execute! (db-connection) ["delete from games where id=?" id]))

(defn subscribe-to-game-as [{game_id :game_id nb :weare, device :device}]
  (let [game (search-game game_id)
         newgame (if (= 0 (read-string nb))
                     (update-in game [:subscriptions] dissoc device)
                     (assoc-in game [:subscriptions device] nb))]
       (update-game newgame)))

(defn delete-reservation [idReservation]
  (j/execute! (db-connection) ["delete from wp_em_bookings where booking_id=?" idReservation]))

(defn convert-to-booking-meta [reservation]
  (let [attendees [{"attendee_name" (:name reservation)}]
         booking-meta {"attendees" {"1" attendees}}]
       (clj->php booking-meta)))

(defn search-user-by-id [user_id]
  (->
     (j/query (db-connection) ["select display_name as name from wp_users where id=?" user_id])
     (first)))

(defn create-reservation [{:keys [reservation event_id user_id]}]
  (let [current-date (java.util.Date.)
        booking-meta (convert-to-booking-meta reservation)]
     (j/execute! (db-connection) ["insert into wp_em_bookings
													(event_id, person_id, booking_spaces, booking_date, booking_status, booking_meta)
													values
													(?,?,1,?,1,?)" event_id (if (nil? user_id) 0 user_id) current-date booking-meta])))

(defn remove-reservation [{:keys [event_id user_id]}]
  (j/execute! (db-connection) ["delete from wp_em_bookings
																where person_id=? and event_id=?" user_id event_id]))

(defn categories
  "Recherche de toutes les catégories des évènements présentes"
  []
  (-> (j/query (db-connection) "select ter.term_id as id, ter.name as name
																from wp_terms ter
																join wp_term_taxonomy tax ON ter.term_id=tax.term_id
																where taxonomy='event-categories'")))

(defn festivals-to-domain [festivals]
    (map #(rename-keys % {:post_title :name}) festivals))

(defn search-festivals []
    (-> (j/query (db-connection) "select post_title, ID from wp_posts where post_type='festival' and post_status='publish'")
     (festivals-to-domain)))

(defn search-studio-events []
  (->>
    (j/query (db-connection) "select * from studio_events")
    (map #(assoc (parse-string (:event %) true) :id (:id %)))
    (d/ordered-events)))

(defn new-studio-event? [o]
  (nil? (:id o)))

(defn save-studio-event [o]
  (j/execute! (db-connection) ["insert into studio_events (event) VALUES(?)" (generate-string o)]))

(defn update-studio-event [o]
  (j/execute! (db-connection) ["update studio_events set event=? where id=?" (generate-string o) (:id o)]))

(defn create-studio-event [o]
  (if (new-studio-event? o)
    (save-studio-event o)
    (update-studio-event o)))

(defn delete-studio-event [id]
  (j/execute! (db-connection) ["delete from studio_events where id=?" id]))
