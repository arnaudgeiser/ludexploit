(ns ludexploit.handler
  (:require [compojure.core :refer :all]
            [compojure.route :as route]
            [clojure.java.io :refer :all]
            [clojure.set :refer :all]
            [ring.middleware.json :refer [wrap-json-body wrap-json-response]]
            [ring.middleware.basic-authentication :refer [wrap-basic-authentication]]
            [ring.middleware.cors :refer [wrap-cors]]
            [ludexploit.printing :as p]
            [ludexploit.data-access :refer :all]
            [ludexploit.email :as email]
            [ludexploit.config :refer :all]
            [ludexploit.cloud-messaging :as cm]
            [ludexploit.service :as s]
            [ludexploit.domain :refer :all]
            [cheshire.generate :refer [add-encoder]]
            [cheshire.core :refer [generate-string]]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults api-defaults]]
            [clj-time.core :as t]
            [clj-time.format :as f]
            [clj-time.coerce :as c]
            [clj-time.local :as l]
            [crypto.password.bcrypt :refer [encrypt check]]
            [clojure.tools.logging :as log])
    (:import [ch.waterbead PasswordHasher]))

(def pdf-headers {"Content-Type" "application/pdf"})

(def date-formatter
  (f/formatter "dd-MM-yyyy"))

(defn to-sql-date [date] (c/to-sql-date (f/parse date-formatter date)))

(add-encoder org.joda.time.DateTime
    (fn [c jsonGenerator]
      (.writeString jsonGenerator (str c))))

(defn filter-inscriptions [events]
  (filter #(and (:hasinscriptions %) (< (:ticket_spaces %) 100)) events))

  (defn emails-from-event [event]
    (for [r (:reservations event)
    :let [address (:user_email r)]
    :when (not (nil? address))]
      address))

(defn emails [events]
  (flatten (map #(emails-from-event %) events)))

(defn send-message [req]
  (let [idEvent (get-in req [:route-params :idEvent])
        email (:body req)
        event (search-event idEvent)
        adresses (emails event)
        email-to-send (assoc email :to adresses)]
          (if (seq? adresses) (do (email/send-message email-to-send) event))))

(defn create-and-get-reservation [req]
  (let [data (assoc (:body req) :event_id (get-in req [:route-params :idEvent]))]
    (do
      (create-reservation data)
      (search-event (:event_id data)))))

(defn search-events-by-day [events day]
  (for [e events
        :let [start-date (:event_start_date e)]
        :when (= (t/day-of-week start-date) (Integer/parseInt day))]
        e))

(defn authenticated? [name pass]
  (let [users (:users @config)
        password (get users name)]
  (if (nil? password) false (check pass password))))

  (defn is-match? [password user]
    (let [hasher (PasswordHasher. 8)]
      (.CheckPassword hasher password (:user_pass user))))

(defn user-authenticated? [name pass]
  (let [db-user (search-user name)]
  (try
    (is-match? pass db-user)
    (catch Exception e false))))

(defn login [{name :username pass :password}]
  (let [db-user (search-user name)]
  (if (is-match? pass db-user) (select-keys db-user [:id]) {})))

(defn is-online []
  (t/after? (l/local-now) (l/to-local-date-time (get-in @config [:infos :start]))))

(defroutes app-routes
  (POST "/login" [] (generate-string "Seems to be ok!"))
  (GET "/festivals/:idFestival/events" [idFestival] (sort-by :event_name (search-events-by-festival idFestival)))
  (GET "/events/:idEvent" [idEvent] (search-event idEvent))
  (GET "/events/:idEvent/emails" [idEvent] (emails (search-event idEvent)))
  (PUT "/events/:idEvent/send" req (generate-string (first (send-message req))))
  (POST "/events/:idEvent/reservations" req (generate-string (create-and-get-reservation req)))
  (DELETE "/reservations/:idReservation" [idReservation] (do (delete-reservation idReservation)) {})
  (POST "/notifications/send" req (generate-string (cm/send-notification (:body req))))
  (POST "/reservations" req (create-reservation (:body req)))
  (route/not-found "Not Found"))

(defroutes util-routes
  (GET "/festivals" [] (search-festivals))
  (GET "/encrypt/:password" [password] (encrypt password))
  (GET "/events/:idEvent/print" [idEvent] {:headers pdf-headers :body (p/print-programme [(search-event idEvent)])})
  (GET "/festivals/:idFestival/print" [idFestival] {:headers pdf-headers :body (p/print-programme (filter-inscriptions (search-events-by-festival idFestival)))})
  (GET "/festivals/bydate/:date/print" [date] {:headers pdf-headers :body (p/print-programme (filter-inscriptions (search-events-by-date (to-sql-date date))))})
  (GET "/festivals/:idFestival/byday/:day/print" [idFestival day] {:headers pdf-headers :body (p/print-programme (filter-inscriptions (search-events-by-day (search-events-by-festival idFestival) day)))})
  (GET "/festivals/:idFestival/byday/:day" [idFestival day] (generate-string (search-events-by-day (search-events-by-festival idFestival) day))))

; Public routes for users API
(defroutes public-routes
  (GET "/public/festivals/:idFestival/events" [idFestival] (events-for-everyone (search-events-by-festival idFestival)))
  (GET "/public/events/:idEvent" [idEvent] (generate-string (event-for-everyone (search-event idEvent))))
  (GET "/public/places" [] (search-places))
  (GET "/public/categories" [] (categories))
  (GET "/public/festivals/:idFestival/users/:idUser/reservations" [idFestival idUser] (search-events-by-festival-user idFestival idUser))
  (GET "/public/games" [] (search-games))
  (DELETE "/public/games/:id" req (delete-game (:body req)))
  (GET "/public/games/online" [] (is-online))
  (POST "/public/games/:id/subscribe" req (if (is-online) (subscribe-to-game-as (:body req)) {:status 400}))
  (POST "/public/games" req (if (is-online) (s/create-game (:body req)) {:status 400}))
  (GET "/public/secured/users/:idUser/reservations/:idFestival" [idUser idFestival] (search-reservations idFestival idUser))
  (POST "/public/secured/login" req (generate-string (login (:body req))))
  (POST "/public/secured/users/:idUser/events/:idEvent/subscribe" [idUser idEvent] (generate-string (s/subscribe-event idEvent idUser)))
  (POST "/public/secured/users/:idUser/events/:idEvent/unsubscribe" [idUser idEvent] (generate-string (s/unsubscribe-event idEvent idUser))))

(defn wrap-override-cors [routes]
  (wrap-cors routes :access-control-allow-origin [#".*"] :access-control-allow-methods [:get :put :post :delete] :access-control-allow-credentials "true"))

(defroutes app
  (ANY "*" [] (-> util-routes
    (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
    (wrap-override-cors)
    (wrap-json-response)))
  (ANY "/public/secured/*" [] (-> public-routes
    (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
    (wrap-override-cors)
    (wrap-json-response)
    (wrap-json-body {:keywords? true})
    (wrap-basic-authentication user-authenticated? nil {:body (generate-string {:reason "Wrong credentials"})})
  ))
  (ANY "/public/*" [] (-> public-routes
    (wrap-override-cors)
    (wrap-json-body {:keywords? true})
    (wrap-json-response)))
  (ANY "*" [] (-> app-routes
    (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
    (wrap-json-body {:keywords? true})
    (wrap-json-response)
    (wrap-basic-authentication authenticated? nil {:body (generate-string {:reason "Wrong credentials"})})
    (wrap-override-cors))))
