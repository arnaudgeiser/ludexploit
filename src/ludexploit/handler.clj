(ns ludexploit.handler
  (:require [compojure.core :refer :all]
            [compojure.route :as route]
            [clojure.java.io :refer :all]
            [clojure.set :refer :all]
            [ring.middleware.json :refer [wrap-json-body wrap-json-response]]
            [ring.middleware.basic-authentication :refer [wrap-basic-authentication]]
            [ring.middleware.cors :refer [wrap-cors]]
            [ring.util.response :refer [response]]
            [ludexploit.printing :as p]
            [ludexploit.data-access :refer :all]
            [ludexploit.email :as email]
            [ludexploit.config :refer :all]
            [ludexploit.cloud-messaging :as cm]
            [ludexploit.service :as s]
            [ludexploit.domain :refer :all]
            [ludexploit.util :refer [date-formatter date-time-formatter swiss-date-formatter to-date swiss-date-time-formatter]]
            [cheshire.generate :refer [add-encoder]]
            [cheshire.core :refer [generate-string]]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults api-defaults]]
            [clj-time.core :as t]
            [clj-time.format :as f]
            [clj-time.coerce :as c]
            [clj-time.local :as l]
            [clj-time.periodic :refer [periodic-seq]]
            [crypto.password.bcrypt :refer [encrypt check]]
            [clojure.tools.logging :as log]
            [hiccup.core :refer [html]]
            [chime :refer [chime-at]])

  (:import [ch.waterbead PasswordHasher]
           [org.joda.time DateTimeZone]))

(def pdf-headers {"Content-Type" "application/pdf"})

(defn to-sql-date [date] (c/to-sql-date (f/parse date-formatter date)))

(add-encoder org.joda.time.DateTime
    (fn [c jsonGenerator]
      (.writeString jsonGenerator (str c))))

(defn filter-inscriptions [events]
  (filter #(and (:hasinscriptions %) (< (:ticket_spaces %) 100)) events))

(defn emails-from-event [event]
  (for [r (:reservations event)
        :let [address (:user_email r)]
        :when (not (nil? address))]
    address))

(defn emails [events]
  (flatten (map #(emails-from-event %) events)))

(defn send-message [req]
  (let [idEvent (get-in req [:route-params :idEvent])
        email (:body req)
        event (search-event idEvent)
        adresses (emails event)
        email-to-send (assoc email :to adresses)]
       (if (seq? adresses) (do (email/send-message email-to-send) event))))

(defn create-and-get-reservation [req]
  (let [data (assoc (:body req) :event_id (get-in req [:route-params :idEvent]))]
    (do
      (create-reservation data)
      (search-event (:event_id data)))))

(defn search-events-by-day [events day]
  (for [e events
        :let [start-date (:event_start_date e)]
        :when (= (t/day-of-week start-date) (Integer/parseInt day))]
       e))

(defn authenticated? [name pass]
  (let [users (:users @config)
        password (get users name)]
   (if (nil? password) false (check pass password))))

(defn is-match? [password user]
  (let [hasher (PasswordHasher. 8)]
    (.CheckPassword hasher password (:user_pass user))))

(defn user-authenticated? [name pass]
  (let [db-user (search-user name)]
   (try
     (is-match? pass db-user)
     (catch Exception e false))))

(defn login [{name :username pass :password}]
  (let [db-user (search-user name)]
   (if (is-match? pass db-user) (select-keys db-user [:id]) {})))

(defn is-online []
  (t/after? (l/local-now) (l/to-local-date-time (get-in @config [:infos :start]))))

(defn to-csv [event]
  (let [reservations (:reservations event)
        r (for [attendee (mapcat #(:attendees %) reservations)]
            (clojure.string/join ";" [attendee]))]
    (clojure.string/join "\n" r)))

(defroutes app-routes
  (POST "/login" [] (generate-string "Seems to be ok!"))
  (GET "/festivals/:idFestival/events" [idFestival] (sort-by :event_name (search-events-by-festival idFestival)))
  (GET "/festivals/:idFestival/reservations/awaitingpayment" [idFestival] (generate-string (search-awaiting-payments idFestival)))
  (GET "/events/:idEvent" [idEvent] (search-event idEvent))
  (GET "/events/:idEvent/csv" [idEvent] {:status 200 :headers {"Content-Type" "text/csv"} :body (to-csv (search-event idEvent))})
  (GET "/events/:idEvent/emails" [idEvent] (emails (search-event idEvent)))
  (PUT "/events/:idEvent/send" req (generate-string (first (send-message req))))
  (POST "/events/:idEvent/reservations" req (generate-string (create-and-get-reservation req)))
  (DELETE "/reservations/:idReservation" [idReservation] (do (delete-reservation idReservation)) {})
  (POST "/notifications/send" req (generate-string (cm/send-notification (:body req))))
  (POST "/reservations" req (create-reservation (:body req)))
  (POST "/studio/events" {body :body} (response (create-studio-event body)))
  (DELETE "/studio/events/:id" [id] (response (delete-studio-event id)))
  (route/not-found "Not Found"))

(defroutes util-routes
  (GET "/festivals" [] (search-festivals))
  (GET "/encrypt/:password" [password] (encrypt password))
  (GET "/events/:idEvent/print" [idEvent] {:headers pdf-headers :body (p/print-programme [(search-event idEvent)])})
  (GET "/festivals/:idFestival/print" [idFestival] {:headers pdf-headers :body (p/print-programme (filter-inscriptions (search-events-by-festival idFestival)))})
  (GET "/festivals/bydate/:date/print" [date] {:headers pdf-headers :body (p/print-programme (filter-inscriptions (search-events-by-date (to-sql-date date))))})
  (GET "/festivals/:idFestival/byday/:day/print" [idFestival day] {:headers pdf-headers :body (p/print-programme (filter-inscriptions (search-events-by-day (search-events-by-festival idFestival) day)))})
  (GET "/festivals/:idFestival/byday/:day" [idFestival day] (generate-string (search-events-by-day (search-events-by-festival idFestival) day))))

(defn check-categories [coll]
  (->> coll
    (filter #(or (= (count (:categories %)) 0) (< (count (:categories %)) 2)))
    (map (fn [o] (select-keys o [:categories :event_name])))))

(defn check-inscriptions [coll]
  (->> coll
    (filter #(:hasinscriptions %))
    (map (fn [o] (select-keys o [:event_name :event_start_date :event_end_date :free :ticket_spaces :hasinscriptions :price :categories])))
    (sort-by (fn [o] (first (:categories o))))))


(defn check-publication-date [coll]
  (->> coll
    (map (fn [o] (select-keys o [:categories :event_name :publication_date :event_start_date])))
    (filter #(not (re-seq #"2020-01-28T09" (str (:publication_date %)))))))

(defn send-email-paiements-attentes [id-festival]
  (let [v (search-awaiting-payments2 id-festival)
        now (f/unparse swiss-date-formatter (t/now))
        content (html
                  [:div
                   [:span (str "Etat des inscriptions à la date du " now)]
                   [:table {:style "width:100%"}
                    [:tr
                     [:th {:style "text-align:left"} "Nom"]
                     [:th {:style "text-align:left"} "Animation"]
                     [:th {:style "text-align:left"} "Date début"]
                     [:th {:style "text-align:left"} "Date fin"]
                     [:th {:style "text-align:left"} "Places"]]
                    (for [{:keys [event_name event_start_date event_end_date user_name user_email places dbem_phone nb-days]} v]
                      [:tr
                       [:td {:style "text-align:left"} (str user_name " (" user_email ")")]
                       [:td {:style "text-align:left"} event_name]
                       [:td {:style "text-align:left;width:200px"} (f/unparse swiss-date-time-formatter event_start_date)]
                       [:td {:style "text-align:left;width:200px"} (f/unparse swiss-date-time-formatter event_end_date)]
                       (let [style (if (> nb-days 2) "color:red;text-align:left" "text-align:left")]
                         [:td {:style style} (str places " places " " (depuis " nb-days " jours)")])])]])]
    (email/send-html-message {:to (get-in @config [:notifications :inscriptions-attente-paiement]) :object (str "[Ludesco] Inscriptions en attente de paiement au " now) :content content})))


; Public routes for users API
(defroutes public-routes
  (GET "/public/encrypt/:password" [password] (encrypt password))
  (GET "/public/festivals/:idFestival/events/nodescription" [idFestival] (events-for-everyone (search-events-by-festival-nodescription idFestival)))
  (GET "/public/festivals/:idFestival/events" [idFestival]  (response (events-for-everyone (search-events-by-festival idFestival))))
  (GET "/public/events/:idEvent" [idEvent] (generate-string (event-for-everyone (search-event idEvent))))
  (GET "/public/places" [] (search-places))
  (GET "/public/festivals/:idFestival/check/publication" [idFestival] (response (events-for-everyone (search-events-by-festival idFestival))))
  (GET "/public/festivals/:idFestival/check/categories" [idFestival] (response (check-categories (search-events-check {:festival-id idFestival}))))
  (GET "/public/festivals/:idFestival/check/inscriptions" [idFestival] (response (check-inscriptions (search-events-check {:festival-id idFestival}))))
  (GET "/public/festivals/:idFestival/check/publication-date" [idFestival] (response (check-publication-date (search-events-check {:festival-id idFestival}))))
  (GET "/public/categories" [] (response (s/categories)))
  (GET "/public/categories/:id-category" [id-category] (response (first (s/categories (category-by-id id-category)))))
  (GET "/public/festivals/:idFestival/bycategory/:category" [idFestival category lang] (response (find-events-by-category {:festival-id idFestival :category-id category})))
  (GET "/public/festivals/:idFestival/bycategory/:category/row" [idFestival category lang] (response (search-events {:festival-id idFestival :category-id category} identity)))
  (GET "/public/festivals/:idFestival/users/:idUser/reservations" [idFestival idUser] (search-events-by-festival-user idFestival idUser))
  (GET "/public/games" [] (search-games))
  (DELETE "/public/games/:id" req (delete-game (:body req)))
  (GET "/public/games/online" [] (is-online))
  (POST "/public/games/:id/subscribe" req (if (is-online) (subscribe-to-game-as (:body req)) {:status 400}))
  (POST "/public/games" req (if (is-online) (s/create-game (:body req)) {:status 400}))
  (GET "/public/secured/users/:idUser/reservations/:idFestival" [idUser idFestival] (search-reservations idFestival idUser))
  (POST "/public/secured/login" req (generate-string (login (:body req))))
  (POST "/public/secured/users/:idUser/events/:idEvent/subscribe" [idUser idEvent] (generate-string (s/subscribe-event idEvent idUser)))
  (POST "/public/secured/users/:idUser/events/:idEvent/unsubscribe" [idUser idEvent] (generate-string (s/unsubscribe-event idEvent idUser)))
  (GET "/public/studio/next-events" [] {:body (published-events (search-studio-events)) :studio 200})
  (GET "/public/studio/events" [] (response (search-studio-events)))
  (GET "/public/sendmail/:id-festival" [id-festival] (send-email-paiements-attentes id-festival)))

(defn task1 [time]
  (send-email-paiements-attentes 5175))

(defn init []
  (let [emails (get-in @config [:notifications :inscriptions-attente-paiement])]
    (if (seq emails)
      (chime-at (periodic-seq (.. (t/date-time 2019 1 24) (withZone (DateTimeZone/forID "Europe/Zurich")) (withTime 7 20 0 0)) (-> 1 t/days))
          task1))))

(defn wrap-override-cors [routes]
  (wrap-cors routes :access-control-allow-origin [#".*"] :access-control-allow-methods [:get :put :post :delete] :access-control-allow-credentials "true"))


(defroutes app
  (ANY "*" []
    (-> util-routes
      (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
      (wrap-override-cors)
      (wrap-json-response)))
  (ANY "/public/secured/*" []
    (-> public-routes
      (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
      (wrap-override-cors)
      (wrap-json-response)
      (wrap-json-body {:keywords? true})
      (wrap-basic-authentication user-authenticated? nil {:body (generate-string {:reason "Wrong credentials"})})))
  (ANY "/public/*" []
    (-> public-routes
      (wrap-override-cors)
      (wrap-json-body {:keywords? true})
      (wrap-json-response)))
  (ANY "*" []
    (-> app-routes
      (wrap-defaults (assoc-in site-defaults [:security :anti-forgery] false))
      (wrap-basic-authentication authenticated? nil {:body (generate-string {:reason "Wrong credentials"})})
      (wrap-override-cors)
      (wrap-json-body {:keywords? true})
      (wrap-json-response))))
